::flags::  Topic1  基础调用

图01

<img src="D:/音乐图片/typora图片/image-20220906232437058.png" alt="图01" style="zoom: 67%;" />

图02

<img src="D:/音乐图片/typora图片/image-20220906232513857.png" alt="图02" style="zoom:67%;" />

```
图01 和图02 结合使用在由于一个协议有三个实例， 存在负载均衡就会使用轮询策略，
```



::flags::  Topic2   @Service--dubbo注解的使用原理

图03 ![图03](D:/音乐图片/typora图片/image-20220906233309175.png)

图04

![图04](D:/音乐图片/typora图片/image-20220906233332987.png)

```
上图03 04 的使用只要图3使用了dubbo的注解@Reference 注解，后图4才可以抓取到bean,原因是@Reference 做了两件事情，第一创建Bean对象，第二将Bean对象放到spring容器中，所有才可以使用spring的注解@Autowired 依赖注入使用Bean对象调用方法
```

```properties
注意消费者和提供者配置文件都要有 
## Dubbo Registry
dubbo.registry.address=zookeeper://127.0.0.1:2181
```



图5   图6 负载均衡的使用，

<img src="D:/音乐图片/typora图片/image-20220906235904154.png" alt="image-20220906235904154" style="zoom:80%;" />

![图06](D:/音乐图片/typora图片/image-20220906235915810.png)



```
图5 6 可以使用注解来指定负载均衡的策略，如果提供方和消费方都有指定，以消费方为准

a1  @Reference(version = "default", loadbalance = "roundrobin")  轮询

 a2   @Reference(version = "default", loadbalance = "consistenthash") 一致性hash
hash--说明一下， 第一次循环 如果生成index-1-20883,index-2-20882,index-3-20881,  每一次调用都是按着这个对应关系来调用，
index可以理解为 取余数得到值


a3 最少活跃调用数，例如三个服务实例，分别需要处理的请求是4 2 3，拿如果有新增的请求一定是到第二个变成 4 3 3 ，

#这里说明一下，如何统计每个实例的请求数量， （ 消费者会周期性从zookeeper注册中心获取提供方的信息。 举例，例如根据version="1.0"  ,  instance1 instance2 instance3 ,三个实例都是版本1.0，dubbo在消费端会 创建一个对象来记录每个实例的url和活跃数，也就是请求数， 当前消费者自己统计， 多个消费者之间却是隔离的。目前dubbo实在这个逻辑。
```



::flags::  Topic3  服务超时的处理

图7 服务超时   0102

![图07](D:/音乐图片/typora图片/image-20220907192906258.png)

```
如果消费端在注解里面限定一个超时时间timeout=3000，服务端发出请求开始 3秒后 消费端就会抛出异常是超时，
但是上图是我设置的时间是6秒，也就说可以说 执行一个接口需要5秒，需要5秒 消费端一定会超时异常，但是服务端还是会继续执行完接口，
5秒结束服务端不会报错。  但是如果
```



图8dubbo的集群容错机制

![图08](D:/音乐图片/typora图片/image-20220907202131300.png)

----

开始一次调用， dubbo消费端会再次发两次，1+2 有三次，服务端就是终止调用

```
    @Reference(version = "timeout" ,timeout = 10000, cluster = "failover")   failover默认是这个三次
    failsafe     失败安全，出现异常，直接忽略，通常用于写入日志等操作
    failback     失败自动恢复，后台记录失败的请求，定时重发，通常用于消息通知操作
    failfolking   并行调用多个服务实例，看哪一个成功，其中有一个ok就表示接口发送成功
    failbroadcast  广播所有提供者，逐个调用，所有都成功，更新缓存，
    
    0116
    
    
```

::flags::  Topic4   服务降级

  图8 服务降级



![图09](D:/音乐图片/typora图片/image-20220907225657861.png)

![图10](D:/音乐图片/typora图片/image-20220907224846144.png)

```
如
果出现超时异常     ，，如果调用服务出错，就返回固定内容 使用Mock，就会返回 ben--123
```



::flags::  Topic5    ==本地存根==



图11本地存根

![图11](D:/音乐图片/typora图片/image-20220907224038816.png)



下图     

![图12](D:/音乐图片/typora图片/image-20220907225611310.png)

 1---如果执行 标记 上图 demoService.sayHello()  方法  超时异常  就会执行下面的     return   “ 固定 提示语”

图08  是在消费端 ，图12 是在服务端的具体逻辑，  标记2是对应的，  标记1  3 是 前置和后置处理







下面是  说明的 

![图13](D:/音乐图片/typora图片/image-20220907223913109.png)



---

::flags::  Topic6  ==服务回调==



图14 服务的回调使用

```
当消费者调用服务端后，如果也需要服务端去调用消费端，这就是一个互相调用的过程。回调方式是 在消费端提供的，以new Demo()形式传参到 服务端，这样在完成一次消费者调用服务者后， 服务站会主动调用这个回调函数
        // 用来进行callback  ，new DemoServiceListenerImpl()
        System.out.println(demoService.sayHello("周瑜", "d1", new DemoServiceListenerImpl())); 
        
        一个消费端如果想支持回调，需要编写一个新的接口， 还需要一个回调函数， 必须使用Dubbo协议 长连接，不能使用http协议，
        
```



::question:



```
    public String sayHello(String name, String key, DemoServiceListener callback) {
//   代理对象执行了回调  ，执行了回调，   执行下面的方法会给消费端发送数据
        callback.changed("");
```

   关于dubbo的回调方法使用可以在查阅其他资料 --bilibili视频



![图14](D:/音乐图片/typora图片/image-20220908202812735.png)

  使用 标记注解 sayHello 方法对 下班2 第三个参数进行，是回调的参数，作为回调的参数作为代理对象 



::flags::  Topic6  ==异步调用==

图 15  16 17异步调用

![图15](D:/音乐图片/typora图片/image-20220909002614791.png)

图16服务端  图17 消费端

<img src="D:/音乐图片/typora图片/image-20220909002724468.png" alt="图16" style="zoom:200%;" />

![图17](D:/音乐图片/typora图片/image-20220909002741102.png)



![图18](D:/音乐图片/typora图片/image-20220911103559882.png)



异步调用失败，原因getUrl()拿到的是空指针--未解决

::flags::  Topic7   ==泛化的使用==

图19 泛化调用--可以不依赖 接口进行调用， 常用来测试使用，，



::flags::  Topic8  ==rest方式接口==



dubbo--Rest方式接口， 提供方provide 提供rest接口，

![配置支持两种协议的使用](D:/音乐图片/typora图片/image-20220911170939099.png)

![image-20220911171343648](D:/音乐图片/typora图片/image-20220911171343648.png)

![image-20220911171501289](D:/音乐图片/typora图片/image-20220911171501289.png)

```
#支持rest协议，这里测试RestDemoService   ,类上添加@Path("demo")  方法也要添加对应的注解

dubbo.protocols.p1.id=dubbo1
dubbo.protocols.p1.name=dubbo
dubbo.protocols.p1.port=20881
dubbo.protocols.p1.host=0.0.0.0
#
dubbo.protocols.p2.id=rest
dubbo.protocols.p2.name=rest
dubbo.protocols.p2.port=8083
dubbo.protocols.p2.host=0.0.0.0
```



 消费方不是使用dubbo协议,而是使用http协议，例如springMVC 调用的,实例选用p2就行了，

通过上面的三个图片的配置，就实现了 支持两个协议的使用--这个重要

::smiling_imp:



------







笔记连接

[Dubbo入门应用与框架内部设计模型 · 语雀 (yuque.com)](https://www.yuque.com/renyong-jmovm/dadudu/vxhmyy)

![image-20221027100440415](D:\音乐图片\typora图片/image-20221027100440415.png)