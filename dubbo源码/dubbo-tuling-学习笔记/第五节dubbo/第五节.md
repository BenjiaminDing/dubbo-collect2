==第五届

dubbo框架钟    serviceBean.export()  方法  是在spring容器启动之后会 发布一个事件ContextRefreshedEvent  后就会执行下面方法



问：：问你你的服务是什么时候注册到 远程注册中心上去的？？

答案：：在 spring容器启动之后会 发布一个事件ContextRefreshedEvent  后就会执行export（）服务到出，并启动tomcat这个服务



![image-20230513123024965](D:\音乐图片\typora图片\image-20230513123024965.png)



--下面是具体的读取配置中心文件的位置，  优先级是从远程配置中心读取配置 然后会覆盖 （dubbo/config/dubbo-demo-consumer-application/dubbo.properties节点中的内容)

![image-20230513174016504](D:\音乐图片\typora图片\image-20230513174016504.png)

```
        // 如果配置了ConfigCenter
        if (this.configCenter != null) {

            // 从其他位置获取配置中心的相关属性信息，比如配置中心地址
            // TODO there may have duplicate refresh
            this.configCenter.refresh();

            // 属性更新后，从远程配置中心获取数据(应用配置，全局配置)
            prepareEnvironment();
        }

        // 从配置中心取到配置数据后，刷新所有的XxConfig中的属性，除开ServiceConfig
        ConfigManager.getInstance().refreshAll();
    }
```



==dubbo 配置文件的方式有四种 方式 01 dubbo Admin后台管理中心--全局配置  02 使用dubbo.properties文件   03  使用注解@Service()  04 使用系统变量(JVM级别)的设置  System.getProperty() 方法获取==

{

注意配置一个服务的超时时间是指，一个微服务的超时时间；

配置一个应用的超时时间值，一个接口的时间 ，例如一个DemoService.sayHello();



}





==由于服务方两个版本的注册中心监听， 所以 代码也提供了两套



![image-20230513175159457](D:\音乐图片\typora图片\image-20230513175159457.png)

注意文件spring 文件下面是提供给spring启动时候使用地 

--下面是具体的

![image-20230513175346433](D:\音乐图片\typora图片\image-20230513175346433.png)



![image-20230513182152176](D:\音乐图片\typora图片\image-20230513182152176.png)

serviceConfig具体位置的优先级 根据   configCenterFirst = false;    的值



```java
appExternalConfigurationMap --单独这个应用的配置中心
    externalConfigurationMap  --全局配置中心
    PropertiesConfiguration --文件property
    
    
    配置    private boolean configCenterFirst = false;  @Service优先级比远程配置中心的优先级高，反之
```





```jade
if (MethodUtils.isSetter(method)) {
    // 获取xx配置项的value  @Service(timeout = 60)  get()=60
    String value = StringUtils.trim(compositeConfiguration.getString(extractPropertyName(getClass(), method)));
    // isTypeMatch() is called to avoid duplicate and incorrect update, for example, we have two 'setGeneric' methods in ReferenceConfig.
    if (StringUtils.isNotEmpty(value) && ClassUtils.isTypeMatch(method.getParameterTypes()[0], value)) {
        method.invoke(this, ClassUtils.convertPrimitive(method.getParameterTypes()[0], value));
    }
```

```java
 @Service注解的属性
 */
    Class<?> interfaceClass() default void.class;

    /**
     * Interface class name, default value is empty string
     */
    String interfaceName() default "";

    /**
     * Service version, default value is empty string
     */
    String version() default "";

    /**
     * Service group, default value is empty string
     */
    String group() default "";

    /**
     * Service path, default value is empty string
     */
    String path() default "";

    /**
     * Whether to export service, default value is true
     */
    boolean export() default true;

    /**
     * Service token, default value is false
     */
    String token() default "";

    /**
     * Whether the service is deprecated, default value is false
     */
    boolean deprecated() default false;

    /**
     * Whether the service is dynamic, default value is true
     */
    boolean dynamic() default true;

    /**
     * Access log for the service, default value is ""
     */
    String accesslog() default "";

    /**
     * Maximum concurrent executes for the service, default value is 0 - no limits
     */
    int executes() default 0;

    /**
     * Whether to register the service to register center, default value is true
     */
    boolean register() default true;
```





```
dubbo  里面有两个重要的概念  URL--为了封装providerService提供的资源（例如 注册中心 一个服务 dubbo协议 监控中心），

注册中心--具体信息 zookerport:: ip+port+在RegisterConfig类里
Invoker--执行器
```





```java
真正的到处方法  doExportUrls

 private void doExportUrls() {
        // registryURL 表示一个注册中心
        List<URL> registryURLs = loadRegistries(true);

        for (ProtocolConfig protocolConfig : protocols) {

            // pathKey = group/contextpath/path:version
            // 例子：myGroup/user/org.apache.dubbo.demo.DemoService:1.0.1
            String pathKey = URL.buildKey(getContextPath(protocolConfig).map(p -> p + "/" + path).orElse(path), group, version);

            // ProviderModel中存在服务提供者访问路径，实现类，接口，以及接口中的各个方法对应的ProviderMethodModel
            // ProviderMethodModel表示某一个方法，方法名，所属的服务的，
            ProviderModel providerModel = new ProviderModel(pathKey, ref, interfaceClass);

            // ApplicationModel表示应用中有哪些服务提供者和引用了哪些服务
            ApplicationModel.initProviderModel(pathKey, providerModel);

            // 重点
            doExportUrlsFor1Protocol(protocolConfig, registryURLs);
        }
    }



    private void doExportUrlsFor1Protocol(ProtocolConfig protocolConfig, List<URL> registryURLs) {
        
    }
```



一个服务配置两个 注册中心 ，那么 一个ServiceBean也会分别注册到两个注册中心上面去

注册中心上面注册的服务类型

![image-20230513202926941](D:\音乐图片\typora图片\image-20230513202926941.png)



```java
// 监控中心参数
appendParameters(map, metrics);
// 应用相关参数
appendParameters(map, application);
// 模块相关参数
appendParameters(map, module);
// remove 'default.' prefix for configs from ProviderConfig
// appendParameters(map, provider, Constants.DEFAULT_KEY);

// 提供者相关参数
appendParameters(map, provider);

// 协议相关参数
appendParameters(map, protocolConfig);

// 服务本身相关参数
appendParameters(map, this);
```



--

```java
        // 服务url
   URL url = new URL(name, host, port, getContextPath(protocolConfig).map(p -> p + "/" + path).orElse(path), map);
        // url：http://192.168.40.17:80/org.apache.dubbo.demo.DemoService?anyhost=true&application=dubbo-demo-annotation-provider&bean.name=ServiceBean:org.apache.dubbo.demo.DemoService&bind.ip=192.168.40.17&bind.port=80&deprecated=false&dubbo=2.0.2&dynamic=true&generic=false&interface=org.apache.dubbo.demo.DemoService&methods=sayHello&pid=285072&release=&side=provider&timestamp=1585206500409

```





```
    public static UUID randomUUID() {
        SecureRandom ng = Holder.numberGenerator;

        byte[] randomBytes = new byte[16];
        ng.nextBytes(randomBytes);
        randomBytes[6]  &= 0x0f;  /* clear version        */
        randomBytes[6]  |= 0x40;  /* set to version 4     */
        randomBytes[8]  &= 0x3f;  /* clear variant        */
        randomBytes[8]  |= 0x80;  /* set to IETF variant  */
        return new UUID(randomBytes);
    }
    
    UUID类获取token=  @Service属性吗，实际上是一个 安全措施
```

```java
   
        // Token是为了防止服务被消费者直接调用（伪造http请求）
        if (!ConfigUtils.isEmpty(token)) {
            if (ConfigUtils.isDefault(token)) {
                map.put(TOKEN_KEY, UUID.randomUUID().toString());
            } else {
                map.put(TOKEN_KEY, token);
            }
        }
-----  上面是提供方 的
    // 从请求数据种拿到token和 提供方给的token进行对比  ，equal()
        String token = invoker.getUrl().getParameter(TOKEN_KEY);
        if (ConfigUtils.isNotEmpty(token)) {
            Class<?> serviceType = invoker.getInterface();
            Map<String, String> attachments = inv.getAttachments();
            String remoteToken = attachments == null ? null : attachments.get(TOKEN_KEY);
            if (!token.equals(remoteToken)) {
                throw new RpcException("Invalid token! Forbid invoke remote service " + serviceType + " method " + inv.getMethodName() + "() from consumer " + RpcContext.getContext().getRemoteHost() + " to provider " + RpcContext.getContext().getLocalHost());
            }
        }
```





![image-20230513213845777](D:\音乐图片\typora图片\image-20230513213845777.png)





<img src="D:\音乐图片\typora图片\image-20230513213908447.png" alt="image-20230513213908447" style="zoom:150%;" />



```java
dubbo://192.168.77.1:20881/com.tuling.DemoService?anyhost=true&application=dubbo-provider-demo&bind.ip=192.168.77.1&bind.port=20881&deprecated=false&dubbo=2.0.2&dynamic=true&generic=false&interface=com.tuling.DemoService&methods=sayHello,sayHelloAsync&pid=13716&qos.enable=false&release=2.7.5&revision=async&side=provider&timestamp=1683984957722&version=async
```



```java
registry://127.0.0.1:2181/org.apache.dubbo.registry.RegistryService?application=dubbo-provider-demo&dubbo=2.0.2&export=dubbo%3A%2F%2F192.168.77.1%3A20881%2Fcom.tuling.DemoService%3Fanyhost%3Dtrue%26application%3Ddubbo-provider-demo%26bind.ip%3D192.168.77.1%26bind.port%3D20881%26deprecated%3Dfalse%26dubbo%3D2.0.2%26dynamic%3Dtrue%26generic%3Dfalse%26interface%3Dcom.tuling.DemoService%26methods%3DsayHello%2CsayHelloAsync%26pid%3D13716%26qos.enable%3Dfalse%26release%3D2.7.5%26revision%3Dasync%26side%3Dprovider%26timestamp%3D1683984957722%26version%3Dasync&pid=13716&qos.enable=false&registry=zookeeper&release=2.7.5&timestamp=1683984957721
```

==上面就是一个 接口注册到zookkeeper 的url值实际就是 一个 key--value方式，也就是 使用@Service()注解发布到 注册中心的 ServiceBean  一个类



```java
// 服务的register参数，如果为true，则表示要注册到注册中心
if (logger.isInfoEnabled()) {
    if (url.getParameter(REGISTER_KEY, true)) {
        logger.info("Register dubbo service " + interfaceClass.getName() + " url " + url + " to registry " + registryURL);
    } else {
        logger.info("Export dubbo service " + interfaceClass.getName() + " to url " + url);
    }
}

上面这个日志  就是服务注册到 注册中心 打印的日志吧
```





==动态代理机制默认 下面

```
@SPI("javassist")
public interface ProxyFactory {
```



```java
// 到此为止做了哪些事情？ ServiceBean.export()-->刷新ServiceBean的参数-->得到注册中心URL和协议URL-->遍历每个协议URL-->组成服务URL-->生成可执行服务Invoker-->导出服务
Exporter<?> exporter = protocol.export(wrapperInvoker);
```



```java
registry://127.0.0.1:2181/org.apache.dubbo.registry.RegistryService?application=dubbo-provider-demo&dubbo=2.0.2&export=dubbo%3A%2F%2F192.168.77.1%3A20881%2Fcom.tuling.DemoService%3Fanyhost%3Dtrue%26application%3Ddubbo-provider-demo%26bind.ip%3D192.168.77.1%26bind.port%3D20881%26deprecated%3Dfalse%26dubbo%3D2.0.2%26dynamic%3Dtrue%26generic%3Dfalse%26interface%3Dcom.tuling.DemoService%26methods%3DsayHello%2CsayHelloAsync%26pid%3D13716%26qos.enable%3Dfalse%26release%3D2.7.5%26revision%3Dasync%26side%3Dprovider%26timestamp%3D1683984957722%26version%3Dasync&pid=13716&qos.enable=false&registry=zookeeper&release=2.7.5&timestamp=1683984957721

==获取到上面的一个数据， 简化以后存到zookeeper


```

![简化数据 存放到zookeeper](D:\音乐图片\typora图片\image-20230514084435602.png)





涉及的类  RegistryProtocol--   RegistryProtoco.register(registryUrl, registeredProviderUrl);-----   nterface RegistryService  .register(URL url);---  FailbackRegistry.register()----  FailbackRegistry.addFailedUnregistered(url);

```
// 重试一下 请求
addFailedUnregistered(url);



        // export invoker
        // 根据动态配置重写了providerUrl之后，就会调用DubboProtocol或HttpProtocol去进行导出服务了
        // 启动tomcat Netty
        final ExporterChangeableWrapper<T> exporter = doLocalExport(originInvoker, providerUrl);
```





```
DobboProtocol类
@Override
public <T> Exporter<T> export(Invoker<T> invoker) throws RpcException {
    URL url = invoker.getUrl();
    
    --- DobboProtocol类
        // 构造一个Exporter进行服务导出
        DubboExporter<T> exporter = new DubboExporter<T>(invoker, key, exporterMap);
        exporterMap.put(key, exporter);
        
        Transporters类
```



![服务的启动顺序哈哈0-1-2-3四步走](D:\音乐图片\typora图片\image-20230514151809992.png)



==监听==



```

// 订阅 服务接口名+group+version+".configurators"
this.initWith(DynamicConfiguration.getRuleKey(providerUrl) + CONFIGURATORS_SUFFIX);
```



```

        /**
         * Only if the new url going to Registry is different with the previous one should we do unregister and register.
         * 如果新的服务提供者url简化后的url和这个服务之前的服务提供者url简化后的url不相等，则需要把新的简化后的服务提供者url注册到注册中心去
         */
        if (providerInvokerWrapper.isReg() && !registeredProviderUrl.equals(providerInvokerWrapper.getProviderUrl())) {
            unregister(registryUrl, providerInvokerWrapper.getProviderUrl());
            register(registryUrl, registeredProviderUrl);
            newProviderInvokerWrapper.setReg(true);
        }
        
        
        修改配置不需要重启Netty 
```





面试问题收集：：

01 dubbo导出的流程ace