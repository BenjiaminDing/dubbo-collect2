::flags: Topic 01

![dubbo-spi-机制原理分析](D:/音乐图片/typora图片/dubbo-spi-机制原理分析.jpg)



==JAVA的SPI有应用再数据库连接方面（例如jdbc去连接数据库，涉及多种数据源，mysql oracle ，如何解决这个问题就是使用ServiceLoader类==

那dubbo是如何使用的处理类似问题的呢？？

::flags: Topic 02 ==是否是Wrapper的处理==

![是否是Wrapper的处理](D:/音乐图片/typora图片/image-20220911203228754.png)

::flags: Topic 03  ==加载数据到接口的实现类为扩展点==

![image-20220911203524550](D:/音乐图片/typora图片/image-20220911203524550.png)

::flags: Topic 04  ==类似spring的依赖注入，属性填充==



```java
使用dubbo.protocols.p1.name=dubbo  key-value 方式来定义一个协议类型， 扫描后根据dubbo调用相应的jar包

如果一个类实现了接口，又有传入这个接口的构造方法，就是一个wrapper,AOP的使用
```

<img src="D:/音乐图片/typora图片/image-20220911190728869.png" alt="image-20220911190728869"  />

==type--一个值介意一个接口interface---Car  ，一个接口有多个扩展点---就是多个实现类==

::flags: Topic 04  ==@Extension注解的使用==

-------

![image-20220912111951699](D:/音乐图片/typora图片/image-20220912111951699.png)

```

    @Extension()  注解的使用过判断 
    
    @SuppressWarnings("deprecation")
    private String findAnnotationName(Class<?> clazz) {
        org.apache.dubbo.common.Extension extension = clazz.getAnnotation(org.apache.dubbo.common.Extension.class);
        if (extension != null) {
            return extension.value();
        }

```

::flags: Topic 05  ==@SPI注解的使用,就是声明了一个可以进行扩展的接口==

![image-20220912113148936](D:/音乐图片/typora图片/image-20220912113148936.png)

```

@SPI("red")
public interface Car {

    @Adaptive
    String getCarName();

    String sayHell();


}

--在扫描文件之前使用@SPI()注解 创建扩展点




---特殊的一个  @SPI

/**
 * ExtensionFactory 这个接口有多个扩展点，也就是有多个实现类，AdaptiveExtensionFactory--是
 */
@SPI
public interface ExtensionFactory {

    /**
     * Get extension.
     *
     * @param type object type.
     * @param name object name.
     * @return object instance.
     */
    <T> T getExtension(Class<T> type, String name);

}
```

::flags: Topic 05  ==实例化一个扩展类 new ExtensionLoader<T>(type)==

![image-20220912113300536](D:/音乐图片/typora图片/image-20220912113300536.png)



```
objectFactory--就是        // ExtensionFactory.getAdaptiveExtension())得到的就是 AdaptiveExtensionFactory
   
   objectFactory = (type == ExtensionFactory.class ? null : ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension());
```





::flags: Topic 06  ==代理对象的生成==

```
dubbo代理类的生成的方法

    private Class<?> createAdaptiveExtensionClass() {
        // cachedDefaultName表示接口默认的扩展类
        String code = new AdaptiveClassCodeGenerator(type, cachedDefaultName).generate();

        ClassLoader classLoader = findClassLoader();
        org.apache.dubbo.common.compiler.Compiler compiler = ExtensionLoader.getExtensionLoader(org.apache.dubbo.common.compiler.Compiler.class).getAdaptiveExtension();
        return compiler.compile(code, classLoader);
    }
```



==::flags: Topic 07==通过构造方法创建对象-反射==

![image-20220912113836598](D:/音乐图片/typora图片/image-20220912113836598.png)



==其他补充==

```java
dubbo的限制使用


@SPI("red")
public interface Car {

    @Adaptive//??
    String getCarName(URL url);
    
}
-------------------

   
  private static final ConcurrentMap<Class<?>, ExtensionLoader<?>> EXTENSION_LOADERS = new ConcurrentHashMap<>();--放入map的是一个接口的多个扩展点

    private static final ConcurrentMap<Class<?>, Object> EXTENSION_INSTANCES = new ConcurrentHashMap<>();--接口的实现类对象
```





```
D:\Location\技术积累区\dubbo-rpc框架\dubbo学习笔记和源码\dubbo源码学习\dubbo源码\dubbo-tuling-学习笔记\第五节dubbo\dubbovip\dubbo-demo\dubbo-demo-api\dubbo-demo-api-provider\src\main\java\org\apache\dubbo\demo\provider



第五节 启动上面的路径main方法 进行debug
```



