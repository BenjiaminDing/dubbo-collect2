==服务的迪奥用



01。

```java
invoker = PROXY_FACTORY.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(EXPORT_KEY, url.toFullString()));

    @Adaptive({PROXY_KEY})
    <T> Invoker<T> getInvoker(T proxy, Class<T> type, URL url) throws RpcException;

三个入参一次对应  ref接口的具体实现类 type就是类型，


    /**
     * The reference of the interface implementation
     */
    private T ref;  上面传入的REF就是 实际的一个  DemoSeviceImpl  或者说需要注册上去的一个实例
```



```java
//数据传输时候分为两层
ExchangeClient----数据交换层----ExchangeServer       （这一层 设计为了 ，请求和响应  , 或者可以理解未ExChangeServer包了一层NettyServer
    NettyClient-----sockert，数据传输层-----NettyServer


        // 通过url绑定端口，和对应的请求处理器
        ExchangeServer server;
        try {
            // requestHandler是请求处理器，类型为ExchangeHandler
            // 表示从url的端口接收到请求后，requestHandler来进行处理
            server = Exchangers.bind(url, requestHandler);
        } catch (RemotingException e) {
            throw new RpcException("Fail to start server(url: " + url + ") " + e.getMessage(), e);
        }



```







dubbo源码启动Netty方法

```jade
 @Override
    protected void doOpen() throws Throwable {
        NettyHelper.setNettyLoggerFactory();

        // boss线程，主要监听端口和分配socketChannel给worker线程
        ExecutorService boss = Executors.newCachedThreadPool(new NamedThreadFactory("NettyServerBoss", true));
        // worker线程负责数据读写
        ExecutorService worker = Executors.newCachedThreadPool(new NamedThreadFactory("NettyServerWorker", true));
        // iothreads就是读写数据的线程
        ChannelFactory channelFactory = new NioServerSocketChannelFactory(boss, worker, getUrl().getPositiveParameter(IO_THREADS_KEY, Constants.DEFAULT_IO_THREADS));
        bootstrap = new ServerBootstrap(channelFactory);

        // 连接处理器，建立连接、连接断开、接收到数据、返回数据的逻辑都在这个Handler里面
        // this表示的是NettyServer，在它的父类AbstractServer
        final NettyHandler nettyHandler = new NettyHandler(getUrl(), this);
        channels = nettyHandler.getChannels();
        // https://issues.jboss.org/browse/NETTY-365
        // https://issues.jboss.org/browse/NETTY-379
        // final Timer timer = new HashedWheelTimer(new NamedThreadFactory("NettyIdleTimer", true));
        bootstrap.setOption("child.tcpNoDelay", true);
        bootstrap.setOption("backlog", getUrl().getPositiveParameter(BACKLOG_KEY, Constants.DEFAULT_BACKLOG));
        bootstrap.setPipelineFactory(new ChannelPipelineFactory() {
            @Override
            public ChannelPipeline getPipeline() {
                NettyCodecAdapter adapter = new NettyCodecAdapter(getCodec(), getUrl(), NettyServer.this);
                ChannelPipeline pipeline = Channels.pipeline();
                /*int idleTimeout = getIdleTimeout();
                if (idleTimeout > 10000) {
                    pipeline.addLast("timer", new IdleStateHandler(timer, idleTimeout / 1000, 0, 0));
                }*/
                pipeline.addLast("decoder", adapter.getDecoder());
                pipeline.addLast("encoder", adapter.getEncoder());
                pipeline.addLast("handler", nettyHandler);
                return pipeline;
            }
        });
        // bind
        channel = bootstrap.bind(getBindAddress());
    }
```



```java

    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        // 接收到数据
        NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler);
        try {
            handler.received(channel, msg);
        } finally {

            NettyChannel.removeChannelIfDisconnected(ctx.channel());
        }
    }
    
    //当请求发过来 ，为啥使用channel 放入received() 方法原因是需要接受响应
    
```







```java
    @Override
    protected Object decodeBody(Channel channel, InputStream is, byte[] header) throws IOException {
        byte flag = header[2], proto = (byte) (flag & SERIALIZATION_MASK);
        // get request id.
        long id = Bytes.bytes2long(header, 4);
        
        //DubboCodec类  ---对 dubbo协议的反序列化
```

[第六节: Dubbo服务引入源码解析 (yuque.com)](https://www.yuque.com/renyong-jmovm/rfwlqe/dm83cc#8Drwg)

密码kkys

